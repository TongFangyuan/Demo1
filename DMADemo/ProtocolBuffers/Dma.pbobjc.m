// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dma.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import <stdatomic.h>

#import "Dma.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdirect-ivar-access"

#pragma mark - DmaRoot

@implementation DmaRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - DmaRoot_FileDescriptor

static GPBFileDescriptor *DmaRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum Transport

GPBEnumDescriptor *Transport_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "BluetoothLowEnergy\000BluetoothRfcomm\000Bluet"
        "oothIap\000";
    static const int32_t values[] = {
        Transport_BluetoothLowEnergy,
        Transport_BluetoothRfcomm,
        Transport_BluetoothIap,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Transport)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Transport_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Transport_IsValidValue(int32_t value__) {
  switch (value__) {
    case Transport_BluetoothLowEnergy:
    case Transport_BluetoothRfcomm:
    case Transport_BluetoothIap:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum ErrorCode

GPBEnumDescriptor *ErrorCode_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Success\000Unknown\000Internal\000Unsupported\000Use"
        "rCancelled\000NotFound\000Invalid\000Busy\000NotInPa"
        "irMode\000SignVerifyFail\000";
    static const int32_t values[] = {
        ErrorCode_Success,
        ErrorCode_Unknown,
        ErrorCode_Internal,
        ErrorCode_Unsupported,
        ErrorCode_UserCancelled,
        ErrorCode_NotFound,
        ErrorCode_Invalid,
        ErrorCode_Busy,
        ErrorCode_NotInPairMode,
        ErrorCode_SignVerifyFail,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(ErrorCode)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:ErrorCode_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL ErrorCode_IsValidValue(int32_t value__) {
  switch (value__) {
    case ErrorCode_Success:
    case ErrorCode_Unknown:
    case ErrorCode_Internal:
    case ErrorCode_Unsupported:
    case ErrorCode_UserCancelled:
    case ErrorCode_NotFound:
    case ErrorCode_Invalid:
    case ErrorCode_Busy:
    case ErrorCode_NotInPairMode:
    case ErrorCode_SignVerifyFail:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum Command

GPBEnumDescriptor *Command_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "ProvideSpeech\000ProvideSpeechAck\000StartSpee"
        "ch\000StartSpeechAck\000StopSpeech\000StopSpeechA"
        "ck\000EndPointSpeech\000EndPointSpeechAck\000Noti"
        "fySpeechState\000NotifySpeechStateAck\000GetDe"
        "viceInformation\000GetDeviceInformationAck\000"
        "GetDeviceConfiguration\000GetDeviceConfigur"
        "ationAck\000NotifyDeviceConfiguration\000Notif"
        "yDeviceConfigurationAck\000Pair\000PairAck\000Get"
        "State\000GetStateAck\000SetState\000SetStateAck\000S"
        "ynchronizeState\000SynchronizeStateAck\000Forw"
        "ardAtCommand\000ForwardAtCommandAck\000";
    static const int32_t values[] = {
        Command_ProvideSpeech,
        Command_ProvideSpeechAck,
        Command_StartSpeech,
        Command_StartSpeechAck,
        Command_StopSpeech,
        Command_StopSpeechAck,
        Command_EndPointSpeech,
        Command_EndPointSpeechAck,
        Command_NotifySpeechState,
        Command_NotifySpeechStateAck,
        Command_GetDeviceInformation,
        Command_GetDeviceInformationAck,
        Command_GetDeviceConfiguration,
        Command_GetDeviceConfigurationAck,
        Command_NotifyDeviceConfiguration,
        Command_NotifyDeviceConfigurationAck,
        Command_Pair,
        Command_PairAck,
        Command_GetState,
        Command_GetStateAck,
        Command_SetState,
        Command_SetStateAck,
        Command_SynchronizeState,
        Command_SynchronizeStateAck,
        Command_ForwardAtCommand,
        Command_ForwardAtCommandAck,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(Command)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:Command_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL Command_IsValidValue(int32_t value__) {
  switch (value__) {
    case Command_ProvideSpeech:
    case Command_ProvideSpeechAck:
    case Command_StartSpeech:
    case Command_StartSpeechAck:
    case Command_StopSpeech:
    case Command_StopSpeechAck:
    case Command_EndPointSpeech:
    case Command_EndPointSpeechAck:
    case Command_NotifySpeechState:
    case Command_NotifySpeechStateAck:
    case Command_GetDeviceInformation:
    case Command_GetDeviceInformationAck:
    case Command_GetDeviceConfiguration:
    case Command_GetDeviceConfigurationAck:
    case Command_NotifyDeviceConfiguration:
    case Command_NotifyDeviceConfigurationAck:
    case Command_Pair:
    case Command_PairAck:
    case Command_GetState:
    case Command_GetStateAck:
    case Command_SetState:
    case Command_SetStateAck:
    case Command_SynchronizeState:
    case Command_SynchronizeStateAck:
    case Command_ForwardAtCommand:
    case Command_ForwardAtCommandAck:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AudioSource

GPBEnumDescriptor *AudioSource_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Stream\000";
    static const int32_t values[] = {
        AudioSource_Stream,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AudioSource)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AudioSource_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AudioSource_IsValidValue(int32_t value__) {
  switch (value__) {
    case AudioSource_Stream:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AudioProfile

GPBEnumDescriptor *AudioProfile_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "CloseTalk\000NearField\000FarField\000";
    static const int32_t values[] = {
        AudioProfile_CloseTalk,
        AudioProfile_NearField,
        AudioProfile_FarField,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AudioProfile)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AudioProfile_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AudioProfile_IsValidValue(int32_t value__) {
  switch (value__) {
    case AudioProfile_CloseTalk:
    case AudioProfile_NearField:
    case AudioProfile_FarField:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum AudioFormat

GPBEnumDescriptor *AudioFormat_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PcmL1616KhzMono\000Opus16Khz32KbpsCbr020Ms\000"
        "Opus16Khz16KbpsCbr020Ms\000Msbc\000Speex16Khz1"
        "6Kbps\000Sbc16KhzMono16Kbps28Bitpool16Numbl"
        "ocks8SubbandsSnr\000";
    static const int32_t values[] = {
        AudioFormat_PcmL1616KhzMono,
        AudioFormat_Opus16Khz32KbpsCbr020Ms,
        AudioFormat_Opus16Khz16KbpsCbr020Ms,
        AudioFormat_Msbc,
        AudioFormat_Speex16Khz16Kbps,
        AudioFormat_Sbc16KhzMono16Kbps28Bitpool16Numblocks8SubbandsSnr,
    };
    static const char *extraTextFormatInfo = "\005\000c\203\203b\344\000\001d\203b\203c\343\201\203A\000\002d\203b\203c\343\201\203A\000\004e\203b\203c\000\005c\203b\344\203c\203f\203h\202g\343\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(AudioFormat)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:AudioFormat_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL AudioFormat_IsValidValue(int32_t value__) {
  switch (value__) {
    case AudioFormat_PcmL1616KhzMono:
    case AudioFormat_Opus16Khz32KbpsCbr020Ms:
    case AudioFormat_Opus16Khz16KbpsCbr020Ms:
    case AudioFormat_Msbc:
    case AudioFormat_Speex16Khz16Kbps:
    case AudioFormat_Sbc16KhzMono16Kbps28Bitpool16Numblocks8SubbandsSnr:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SpeechState

GPBEnumDescriptor *SpeechState_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Idle\000Listening\000Processing\000Speaking\000";
    static const int32_t values[] = {
        SpeechState_Idle,
        SpeechState_Listening,
        SpeechState_Processing,
        SpeechState_Speaking,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SpeechState)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SpeechState_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SpeechState_IsValidValue(int32_t value__) {
  switch (value__) {
    case SpeechState_Idle:
    case SpeechState_Listening:
    case SpeechState_Processing:
    case SpeechState_Speaking:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum InitiatorType

GPBEnumDescriptor *InitiatorType_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "PressAndHold\000Tap\000PhoneWakeup\000WaitFollowW"
        "akeup\000";
    static const int32_t values[] = {
        InitiatorType_PressAndHold,
        InitiatorType_Tap,
        InitiatorType_PhoneWakeup,
        InitiatorType_WaitFollowWakeup,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(InitiatorType)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:InitiatorType_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL InitiatorType_IsValidValue(int32_t value__) {
  switch (value__) {
    case InitiatorType_PressAndHold:
    case InitiatorType_Tap:
    case InitiatorType_PhoneWakeup:
    case InitiatorType_WaitFollowWakeup:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum SignMethod

GPBEnumDescriptor *SignMethod_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "Sha256\000Sha1\000Md5Sum\000";
    static const int32_t values[] = {
        SignMethod_Sha256,
        SignMethod_Sha1,
        SignMethod_Md5Sum,
    };
    static const char *extraTextFormatInfo = "\001\002b\002b\000";
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SignMethod)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SignMethod_IsValidValue
                              extraTextFormatInfo:extraTextFormatInfo];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SignMethod_IsValidValue(int32_t value__) {
  switch (value__) {
    case SignMethod_Sha256:
    case SignMethod_Sha1:
    case SignMethod_Md5Sum:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - ControlEnvelope

@implementation ControlEnvelope

@dynamic payloadOneOfCase;
@dynamic command;
@dynamic requestId;
@dynamic response;
@dynamic provideSpeech;
@dynamic startSpeech;
@dynamic stopSpeech;
@dynamic endPointSpeech;
@dynamic notifySpeechState;
@dynamic getDeviceInformation;
@dynamic getDeviceConfiguration;
@dynamic notifyDeviceConfiguration;
@dynamic getState;
@dynamic setState;
@dynamic synchronizeState;
@dynamic forwardAtcommand;
@dynamic sign2;
@dynamic rand2;

typedef struct ControlEnvelope__storage_ {
  uint32_t _has_storage_[2];
  Command command;
  NSString *requestId;
  NSString *sign2;
  NSString *rand2;
  Response *response;
  ProvideSpeech *provideSpeech;
  StartSpeech *startSpeech;
  StopSpeech *stopSpeech;
  EndPointSpeech *endPointSpeech;
  NotifySpeechState *notifySpeechState;
  GetDeviceInformation *getDeviceInformation;
  GetDeviceConfiguration *getDeviceConfiguration;
  NotifyDeviceConfiguration *notifyDeviceConfiguration;
  GetState *getState;
  SetState *setState;
  SynchronizeState *synchronizeState;
  ForwardATCommand *forwardAtcommand;
} ControlEnvelope__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.enumDescFunc = Command_EnumDescriptor,
        .number = ControlEnvelope_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, command),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "requestId",
        .dataTypeSpecific.className = NULL,
        .number = ControlEnvelope_FieldNumber_RequestId,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, requestId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign2",
        .dataTypeSpecific.className = NULL,
        .number = ControlEnvelope_FieldNumber_Sign2,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, sign2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "rand2",
        .dataTypeSpecific.className = NULL,
        .number = ControlEnvelope_FieldNumber_Rand2,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, rand2),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "response",
        .dataTypeSpecific.className = GPBStringifySymbol(Response),
        .number = ControlEnvelope_FieldNumber_Response,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, response),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "provideSpeech",
        .dataTypeSpecific.className = GPBStringifySymbol(ProvideSpeech),
        .number = ControlEnvelope_FieldNumber_ProvideSpeech,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, provideSpeech),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "startSpeech",
        .dataTypeSpecific.className = GPBStringifySymbol(StartSpeech),
        .number = ControlEnvelope_FieldNumber_StartSpeech,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, startSpeech),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "stopSpeech",
        .dataTypeSpecific.className = GPBStringifySymbol(StopSpeech),
        .number = ControlEnvelope_FieldNumber_StopSpeech,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, stopSpeech),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "endPointSpeech",
        .dataTypeSpecific.className = GPBStringifySymbol(EndPointSpeech),
        .number = ControlEnvelope_FieldNumber_EndPointSpeech,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, endPointSpeech),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifySpeechState",
        .dataTypeSpecific.className = GPBStringifySymbol(NotifySpeechState),
        .number = ControlEnvelope_FieldNumber_NotifySpeechState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, notifySpeechState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getDeviceInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(GetDeviceInformation),
        .number = ControlEnvelope_FieldNumber_GetDeviceInformation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, getDeviceInformation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getDeviceConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(GetDeviceConfiguration),
        .number = ControlEnvelope_FieldNumber_GetDeviceConfiguration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, getDeviceConfiguration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "notifyDeviceConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(NotifyDeviceConfiguration),
        .number = ControlEnvelope_FieldNumber_NotifyDeviceConfiguration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, notifyDeviceConfiguration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "getState",
        .dataTypeSpecific.className = GPBStringifySymbol(GetState),
        .number = ControlEnvelope_FieldNumber_GetState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, getState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "setState",
        .dataTypeSpecific.className = GPBStringifySymbol(SetState),
        .number = ControlEnvelope_FieldNumber_SetState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, setState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "synchronizeState",
        .dataTypeSpecific.className = GPBStringifySymbol(SynchronizeState),
        .number = ControlEnvelope_FieldNumber_SynchronizeState,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, synchronizeState),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "forwardAtcommand",
        .dataTypeSpecific.className = GPBStringifySymbol(ForwardATCommand),
        .number = ControlEnvelope_FieldNumber_ForwardAtcommand,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(ControlEnvelope__storage_, forwardAtcommand),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ControlEnvelope class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ControlEnvelope__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\014\025\r\000\026\013\000\027\n\000\030\016\000\031\021\000\032\024\000\033\026\000\034\031\000\035\010\000\036\010\000\037\020\000 \010b\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t ControlEnvelope_Command_RawValue(ControlEnvelope *message) {
  GPBDescriptor *descriptor = [ControlEnvelope descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlEnvelope_FieldNumber_Command];
  return GPBGetMessageInt32Field(message, field);
}

void SetControlEnvelope_Command_RawValue(ControlEnvelope *message, int32_t value) {
  GPBDescriptor *descriptor = [ControlEnvelope descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:ControlEnvelope_FieldNumber_Command];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void ControlEnvelope_ClearPayloadOneOfCase(ControlEnvelope *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Response

@implementation Response

@dynamic payloadOneOfCase;
@dynamic errorCode;
@dynamic speechProvider;
@dynamic deviceInformation;
@dynamic deviceConfiguration;
@dynamic state;
@dynamic pairInformation;

typedef struct Response__storage_ {
  uint32_t _has_storage_[2];
  ErrorCode errorCode;
  SpeechProvider *speechProvider;
  DeviceInformation *deviceInformation;
  DeviceConfiguration *deviceConfiguration;
  State *state;
  PairInformation *pairInformation;
} Response__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = ErrorCode_EnumDescriptor,
        .number = Response_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Response__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "speechProvider",
        .dataTypeSpecific.className = GPBStringifySymbol(SpeechProvider),
        .number = Response_FieldNumber_SpeechProvider,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, speechProvider),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceInformation),
        .number = Response_FieldNumber_DeviceInformation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, deviceInformation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "deviceConfiguration",
        .dataTypeSpecific.className = GPBStringifySymbol(DeviceConfiguration),
        .number = Response_FieldNumber_DeviceConfiguration,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, deviceConfiguration),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(State),
        .number = Response_FieldNumber_State,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "pairInformation",
        .dataTypeSpecific.className = GPBStringifySymbol(PairInformation),
        .number = Response_FieldNumber_PairInformation,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(Response__storage_, pairInformation),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Response class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Response__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "payload",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\013\016\000\014\021\000\r\023\000\017\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t Response_ErrorCode_RawValue(Response *message) {
  GPBDescriptor *descriptor = [Response descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Response_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetResponse_ErrorCode_RawValue(Response *message, int32_t value) {
  GPBDescriptor *descriptor = [Response descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:Response_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

void Response_ClearPayloadOneOfCase(Response *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - Dialog

@implementation Dialog

@dynamic id_p;

typedef struct Dialog__storage_ {
  uint32_t _has_storage_[1];
  uint32_t id_p;
} Dialog__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.className = NULL,
        .number = Dialog_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Dialog__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Dialog class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Dialog__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpeechInitiator

@implementation SpeechInitiator

@dynamic type;
@dynamic hasWakeWord, wakeWord;

typedef struct SpeechInitiator__storage_ {
  uint32_t _has_storage_[1];
  SpeechInitiator_Type type;
  SpeechInitiator_WakeWord *wakeWord;
} SpeechInitiator__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = SpeechInitiator_Type_EnumDescriptor,
        .number = SpeechInitiator_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpeechInitiator__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "wakeWord",
        .dataTypeSpecific.className = GPBStringifySymbol(SpeechInitiator_WakeWord),
        .number = SpeechInitiator_FieldNumber_WakeWord,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpeechInitiator__storage_, wakeWord),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechInitiator class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpeechInitiator__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SpeechInitiator_Type_RawValue(SpeechInitiator *message) {
  GPBDescriptor *descriptor = [SpeechInitiator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechInitiator_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetSpeechInitiator_Type_RawValue(SpeechInitiator *message, int32_t value) {
  GPBDescriptor *descriptor = [SpeechInitiator descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechInitiator_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - Enum SpeechInitiator_Type

GPBEnumDescriptor *SpeechInitiator_Type_EnumDescriptor(void) {
  static _Atomic(GPBEnumDescriptor*) descriptor = nil;
  if (!descriptor) {
    static const char *valueNames =
        "None\000PressAndHold\000Tap\000Wakeword\000";
    static const int32_t values[] = {
        SpeechInitiator_Type_None,
        SpeechInitiator_Type_PressAndHold,
        SpeechInitiator_Type_Tap,
        SpeechInitiator_Type_Wakeword,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(SpeechInitiator_Type)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:SpeechInitiator_Type_IsValidValue];
    GPBEnumDescriptor *expected = nil;
    if (!atomic_compare_exchange_strong(&descriptor, &expected, worker)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL SpeechInitiator_Type_IsValidValue(int32_t value__) {
  switch (value__) {
    case SpeechInitiator_Type_None:
    case SpeechInitiator_Type_PressAndHold:
    case SpeechInitiator_Type_Tap:
    case SpeechInitiator_Type_Wakeword:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - SpeechInitiator_WakeWord

@implementation SpeechInitiator_WakeWord

@dynamic startIndexInSamples;
@dynamic endIndexInSamples;

typedef struct SpeechInitiator_WakeWord__storage_ {
  uint32_t _has_storage_[1];
  uint32_t startIndexInSamples;
  uint32_t endIndexInSamples;
} SpeechInitiator_WakeWord__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "startIndexInSamples",
        .dataTypeSpecific.className = NULL,
        .number = SpeechInitiator_WakeWord_FieldNumber_StartIndexInSamples,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpeechInitiator_WakeWord__storage_, startIndexInSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "endIndexInSamples",
        .dataTypeSpecific.className = NULL,
        .number = SpeechInitiator_WakeWord_FieldNumber_EndIndexInSamples,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpeechInitiator_WakeWord__storage_, endIndexInSamples),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechInitiator_WakeWord class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpeechInitiator_WakeWord__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpeechInitiator)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpeechSettings

@implementation SpeechSettings

@dynamic audioProfile;
@dynamic audioFormat;
@dynamic audioSource;

typedef struct SpeechSettings__storage_ {
  uint32_t _has_storage_[1];
  AudioProfile audioProfile;
  AudioFormat audioFormat;
  AudioSource audioSource;
} SpeechSettings__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "audioProfile",
        .dataTypeSpecific.enumDescFunc = AudioProfile_EnumDescriptor,
        .number = SpeechSettings_FieldNumber_AudioProfile,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpeechSettings__storage_, audioProfile),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "audioFormat",
        .dataTypeSpecific.enumDescFunc = AudioFormat_EnumDescriptor,
        .number = SpeechSettings_FieldNumber_AudioFormat,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpeechSettings__storage_, audioFormat),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "audioSource",
        .dataTypeSpecific.enumDescFunc = AudioSource_EnumDescriptor,
        .number = SpeechSettings_FieldNumber_AudioSource,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpeechSettings__storage_, audioSource),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechSettings class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpeechSettings__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t SpeechSettings_AudioProfile_RawValue(SpeechSettings *message) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioProfile];
  return GPBGetMessageInt32Field(message, field);
}

void SetSpeechSettings_AudioProfile_RawValue(SpeechSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioProfile];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SpeechSettings_AudioFormat_RawValue(SpeechSettings *message) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioFormat];
  return GPBGetMessageInt32Field(message, field);
}

void SetSpeechSettings_AudioFormat_RawValue(SpeechSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioFormat];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

int32_t SpeechSettings_AudioSource_RawValue(SpeechSettings *message) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioSource];
  return GPBGetMessageInt32Field(message, field);
}

void SetSpeechSettings_AudioSource_RawValue(SpeechSettings *message, int32_t value) {
  GPBDescriptor *descriptor = [SpeechSettings descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:SpeechSettings_FieldNumber_AudioSource];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - StartSpeech

@implementation StartSpeech

@dynamic hasSettings, settings;
@dynamic hasInitiator, initiator;
@dynamic hasDialog, dialog;

typedef struct StartSpeech__storage_ {
  uint32_t _has_storage_[1];
  SpeechSettings *settings;
  SpeechInitiator *initiator;
  Dialog *dialog;
} StartSpeech__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "settings",
        .dataTypeSpecific.className = GPBStringifySymbol(SpeechSettings),
        .number = StartSpeech_FieldNumber_Settings,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StartSpeech__storage_, settings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "initiator",
        .dataTypeSpecific.className = GPBStringifySymbol(SpeechInitiator),
        .number = StartSpeech_FieldNumber_Initiator,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StartSpeech__storage_, initiator),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dialog",
        .dataTypeSpecific.className = GPBStringifySymbol(Dialog),
        .number = StartSpeech_FieldNumber_Dialog,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(StartSpeech__storage_, dialog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StartSpeech class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StartSpeech__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ProvideSpeech

@implementation ProvideSpeech

@dynamic hasDialog, dialog;

typedef struct ProvideSpeech__storage_ {
  uint32_t _has_storage_[1];
  Dialog *dialog;
} ProvideSpeech__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialog",
        .dataTypeSpecific.className = GPBStringifySymbol(Dialog),
        .number = ProvideSpeech_FieldNumber_Dialog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ProvideSpeech__storage_, dialog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ProvideSpeech class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ProvideSpeech__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpeechProvider

@implementation SpeechProvider

@dynamic hasSettings, settings;
@dynamic hasDialog, dialog;

typedef struct SpeechProvider__storage_ {
  uint32_t _has_storage_[1];
  SpeechSettings *settings;
  Dialog *dialog;
} SpeechProvider__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "settings",
        .dataTypeSpecific.className = GPBStringifySymbol(SpeechSettings),
        .number = SpeechProvider_FieldNumber_Settings,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpeechProvider__storage_, settings),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "dialog",
        .dataTypeSpecific.className = GPBStringifySymbol(Dialog),
        .number = SpeechProvider_FieldNumber_Dialog,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpeechProvider__storage_, dialog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpeechProvider class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpeechProvider__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - StopSpeech

@implementation StopSpeech

@dynamic errorCode;
@dynamic hasDialog, dialog;

typedef struct StopSpeech__storage_ {
  uint32_t _has_storage_[1];
  ErrorCode errorCode;
  Dialog *dialog;
} StopSpeech__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "errorCode",
        .dataTypeSpecific.enumDescFunc = ErrorCode_EnumDescriptor,
        .number = StopSpeech_FieldNumber_ErrorCode,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(StopSpeech__storage_, errorCode),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "dialog",
        .dataTypeSpecific.className = GPBStringifySymbol(Dialog),
        .number = StopSpeech_FieldNumber_Dialog,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(StopSpeech__storage_, dialog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[StopSpeech class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(StopSpeech__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t StopSpeech_ErrorCode_RawValue(StopSpeech *message) {
  GPBDescriptor *descriptor = [StopSpeech descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopSpeech_FieldNumber_ErrorCode];
  return GPBGetMessageInt32Field(message, field);
}

void SetStopSpeech_ErrorCode_RawValue(StopSpeech *message, int32_t value) {
  GPBDescriptor *descriptor = [StopSpeech descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:StopSpeech_FieldNumber_ErrorCode];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - EndPointSpeech

@implementation EndPointSpeech

@dynamic hasDialog, dialog;

typedef struct EndPointSpeech__storage_ {
  uint32_t _has_storage_[1];
  Dialog *dialog;
} EndPointSpeech__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "dialog",
        .dataTypeSpecific.className = GPBStringifySymbol(Dialog),
        .number = EndPointSpeech_FieldNumber_Dialog,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(EndPointSpeech__storage_, dialog),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[EndPointSpeech class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(EndPointSpeech__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifySpeechState

@implementation NotifySpeechState

@dynamic state;

typedef struct NotifySpeechState__storage_ {
  uint32_t _has_storage_[1];
  SpeechState state;
} NotifySpeechState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.enumDescFunc = SpeechState_EnumDescriptor,
        .number = NotifySpeechState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(NotifySpeechState__storage_, state),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifySpeechState class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(NotifySpeechState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t NotifySpeechState_State_RawValue(NotifySpeechState *message) {
  GPBDescriptor *descriptor = [NotifySpeechState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NotifySpeechState_FieldNumber_State];
  return GPBGetMessageInt32Field(message, field);
}

void SetNotifySpeechState_State_RawValue(NotifySpeechState *message, int32_t value) {
  GPBDescriptor *descriptor = [NotifySpeechState descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:NotifySpeechState_FieldNumber_State];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DeviceInformation

@implementation DeviceInformation

@dynamic serialNumber;
@dynamic name;
@dynamic supportedTransportsArray, supportedTransportsArray_Count;
@dynamic deviceType;
@dynamic supportedAudioFormatsArray, supportedAudioFormatsArray_Count;
@dynamic manufacturer;
@dynamic model;
@dynamic firmwareVersion;
@dynamic softwareVersion;
@dynamic initiatorType;
@dynamic productId;
@dynamic classicBluetoothMac;
@dynamic disableHeartBeat;

typedef struct DeviceInformation__storage_ {
  uint32_t _has_storage_[1];
  InitiatorType initiatorType;
  NSString *serialNumber;
  NSString *name;
  GPBEnumArray *supportedTransportsArray;
  NSString *deviceType;
  GPBEnumArray *supportedAudioFormatsArray;
  NSString *manufacturer;
  NSString *model;
  NSString *firmwareVersion;
  NSString *softwareVersion;
  NSString *productId;
  NSString *classicBluetoothMac;
} DeviceInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "serialNumber",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_SerialNumber,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, serialNumber),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "name",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_Name,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, name),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "supportedTransportsArray",
        .dataTypeSpecific.enumDescFunc = Transport_EnumDescriptor,
        .number = DeviceInformation_FieldNumber_SupportedTransportsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, supportedTransportsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "deviceType",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_DeviceType,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, deviceType),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "supportedAudioFormatsArray",
        .dataTypeSpecific.enumDescFunc = AudioFormat_EnumDescriptor,
        .number = DeviceInformation_FieldNumber_SupportedAudioFormatsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, supportedAudioFormatsArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldPacked | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "manufacturer",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_Manufacturer,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, manufacturer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "model",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_Model,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, model),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "firmwareVersion",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_FirmwareVersion,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, firmwareVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "softwareVersion",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_SoftwareVersion,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, softwareVersion),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "initiatorType",
        .dataTypeSpecific.enumDescFunc = InitiatorType_EnumDescriptor,
        .number = DeviceInformation_FieldNumber_InitiatorType,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, initiatorType),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "productId",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_ProductId,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, productId),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "classicBluetoothMac",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_ClassicBluetoothMac,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(DeviceInformation__storage_, classicBluetoothMac),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "disableHeartBeat",
        .dataTypeSpecific.className = NULL,
        .number = DeviceInformation_FieldNumber_DisableHeartBeat,
        .hasIndex = 10,
        .offset = 11,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceInformation class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t DeviceInformation_InitiatorType_RawValue(DeviceInformation *message) {
  GPBDescriptor *descriptor = [DeviceInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInformation_FieldNumber_InitiatorType];
  return GPBGetMessageInt32Field(message, field);
}

void SetDeviceInformation_InitiatorType_RawValue(DeviceInformation *message, int32_t value) {
  GPBDescriptor *descriptor = [DeviceInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:DeviceInformation_FieldNumber_InitiatorType];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - PairInformation

@implementation PairInformation

@dynamic rand;
@dynamic sign;
@dynamic signMethod;

typedef struct PairInformation__storage_ {
  uint32_t _has_storage_[1];
  SignMethod signMethod;
  NSString *rand;
  NSString *sign;
} PairInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "rand",
        .dataTypeSpecific.className = NULL,
        .number = PairInformation_FieldNumber_Rand,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(PairInformation__storage_, rand),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = PairInformation_FieldNumber_Sign,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(PairInformation__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "signMethod",
        .dataTypeSpecific.enumDescFunc = SignMethod_EnumDescriptor,
        .number = PairInformation_FieldNumber_SignMethod,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(PairInformation__storage_, signMethod),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[PairInformation class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(PairInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t PairInformation_SignMethod_RawValue(PairInformation *message) {
  GPBDescriptor *descriptor = [PairInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PairInformation_FieldNumber_SignMethod];
  return GPBGetMessageInt32Field(message, field);
}

void SetPairInformation_SignMethod_RawValue(PairInformation *message, int32_t value) {
  GPBDescriptor *descriptor = [PairInformation descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:PairInformation_FieldNumber_SignMethod];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - DeviceConfiguration

@implementation DeviceConfiguration

@dynamic needsAssistantOverride;
@dynamic needsSetup;

typedef struct DeviceConfiguration__storage_ {
  uint32_t _has_storage_[1];
} DeviceConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "needsAssistantOverride",
        .dataTypeSpecific.className = NULL,
        .number = DeviceConfiguration_FieldNumber_NeedsAssistantOverride,
        .hasIndex = 0,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "needsSetup",
        .dataTypeSpecific.className = NULL,
        .number = DeviceConfiguration_FieldNumber_NeedsSetup,
        .hasIndex = 2,
        .offset = 3,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[DeviceConfiguration class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(DeviceConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDeviceInformation

@implementation GetDeviceInformation


typedef struct GetDeviceInformation__storage_ {
  uint32_t _has_storage_[1];
} GetDeviceInformation__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDeviceInformation class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetDeviceInformation__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - GetDeviceConfiguration

@implementation GetDeviceConfiguration


typedef struct GetDeviceConfiguration__storage_ {
  uint32_t _has_storage_[1];
} GetDeviceConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetDeviceConfiguration class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(GetDeviceConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - NotifyDeviceConfiguration

@implementation NotifyDeviceConfiguration


typedef struct NotifyDeviceConfiguration__storage_ {
  uint32_t _has_storage_[1];
} NotifyDeviceConfiguration__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[NotifyDeviceConfiguration class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(NotifyDeviceConfiguration__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - State

@implementation State

@dynamic valueOneOfCase;
@dynamic feature;
@dynamic boolean;
@dynamic integer;

typedef struct State__storage_ {
  uint32_t _has_storage_[2];
  uint32_t feature;
  uint32_t integer;
} State__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "feature",
        .dataTypeSpecific.className = NULL,
        .number = State_FieldNumber_Feature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(State__storage_, feature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
      {
        .name = "boolean",
        .dataTypeSpecific.className = NULL,
        .number = State_FieldNumber_Boolean,
        .hasIndex = -1,
        .offset = 1,  // Stored in _has_storage_ to save space.
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBool,
      },
      {
        .name = "integer",
        .dataTypeSpecific.className = NULL,
        .number = State_FieldNumber_Integer,
        .hasIndex = -1,
        .offset = (uint32_t)offsetof(State__storage_, integer),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[State class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(State__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    static const char *oneofs[] = {
      "value",
    };
    [localDescriptor setupOneofs:oneofs
                           count:(uint32_t)(sizeof(oneofs) / sizeof(char*))
                   firstHasIndex:-1];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

void State_ClearValueOneOfCase(State *message) {
  GPBDescriptor *descriptor = [message descriptor];
  GPBOneofDescriptor *oneof = [descriptor.oneofs objectAtIndex:0];
  GPBMaybeClearOneof(message, oneof, -1, 0);
}
#pragma mark - GetState

@implementation GetState

@dynamic feature;

typedef struct GetState__storage_ {
  uint32_t _has_storage_[1];
  uint32_t feature;
} GetState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "feature",
        .dataTypeSpecific.className = NULL,
        .number = GetState_FieldNumber_Feature,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(GetState__storage_, feature),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeUInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[GetState class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(GetState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetState

@implementation SetState

@dynamic hasState, state;

typedef struct SetState__storage_ {
  uint32_t _has_storage_[1];
  State *state;
} SetState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(State),
        .number = SetState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetState__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetState class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SynchronizeState

@implementation SynchronizeState

@dynamic hasState, state;

typedef struct SynchronizeState__storage_ {
  uint32_t _has_storage_[1];
  State *state;
} SynchronizeState__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "state",
        .dataTypeSpecific.className = GPBStringifySymbol(State),
        .number = SynchronizeState_FieldNumber_State,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SynchronizeState__storage_, state),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SynchronizeState class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SynchronizeState__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ForwardATCommand

@implementation ForwardATCommand

@dynamic command;

typedef struct ForwardATCommand__storage_ {
  uint32_t _has_storage_[1];
  NSString *command;
} ForwardATCommand__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "command",
        .dataTypeSpecific.className = NULL,
        .number = ForwardATCommand_FieldNumber_Command,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ForwardATCommand__storage_, command),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ForwardATCommand class]
                                     rootClass:[DmaRoot class]
                                          file:DmaRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ForwardATCommand__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
